{
  "version": 3,
  "sources": ["../plugin/index.ts", "../plugin/lib/constant.ts", "../plugin/lib/util.ts", "../plugin/mkcert/index.ts", "../plugin/lib/logger.ts", "../plugin/mkcert/config.ts", "../plugin/lib/request.ts", "../plugin/mkcert/downloader.ts", "../plugin/mkcert/record.ts", "../plugin/mkcert/source.ts", "../plugin/mkcert/version.ts"],
  "sourcesContent": ["import { createLogger, Plugin } from 'vite'\n\nimport { PLUGIN_NAME } from './lib/constant'\nimport { getDefaultHosts } from './lib/util'\nimport Mkcert, { MkcertOptions } from './mkcert'\n\nexport type ViteCertificateOptions = MkcertOptions & {\n  /**\n   * The hosts that needs to generate the certificate.\n   *\n   * @default [\"localhost\",\"local ip addrs\"]\n   */\n  hosts?: string[]\n}\n\nconst plugin = (options: ViteCertificateOptions = {}): Plugin => {\n  return {\n    name: PLUGIN_NAME,\n    apply: 'serve',\n    config: async ({ server = {}, logLevel }) => {\n      if (server.https === false) {\n        return\n      }\n\n      const { hosts = getDefaultHosts(), ...mkcertOptions } = options\n\n      const logger = createLogger(logLevel, {\n        prefix: PLUGIN_NAME\n      })\n      const mkcert = Mkcert.create({\n        logger,\n        ...mkcertOptions\n      })\n\n      await mkcert.init()\n\n      const allHosts =\n        typeof server.host === 'string' ? [...hosts, server.host] : hosts\n      const uniqueHosts = Array.from(new Set(allHosts)).filter(item => !!item)\n\n      const certificate = await mkcert.install(uniqueHosts)\n\n      return {\n        server: {\n          https: {\n            ...certificate\n          }\n        },\n        preview: {\n          https: {\n            ...certificate\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default plugin\n", "import os from 'os'\nimport path from 'path'\n\nexport const PKG_NAME = 'vite-plugin-mkcert'\n\nexport const PLUGIN_NAME = PKG_NAME.replace(/-/g, ':')\n\nexport const PLUGIN_DATA_DIR = path.join(os.homedir(), `.${PKG_NAME}`)\n", "import child_process, { ExecOptions } from 'child_process'\nimport crypto from 'crypto'\nimport fs from 'fs'\nimport os from 'os'\nimport path from 'path'\nimport util from 'util'\n\nimport { PLUGIN_DATA_DIR } from './constant'\n\n/**\n * Check if file exists\n *\n * @param filePath file path\n * @returns does the file exist\n */\nexport const exists = async (filePath: string) => {\n  try {\n    await fs.promises.access(filePath)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Resolve file path with `PLUGIN_DATA_DIR`\n *\n * @param fileName file name\n * @returns absolute path\n */\nexport const resolvePath = (fileName: string) => {\n  return path.resolve(PLUGIN_DATA_DIR, fileName)\n}\n\nexport const mkdir = async (dirname: string) => {\n  const isExist = await exists(dirname)\n\n  if (!isExist) {\n    await fs.promises.mkdir(dirname, { recursive: true })\n  }\n}\n\nexport const ensureDirExist = async (filePath: string) => {\n  const dirname = path.dirname(filePath)\n  await mkdir(dirname)\n}\n\nexport const readFile = async (filePath: string) => {\n  const isExist = await exists(filePath)\n  return isExist ? (await fs.promises.readFile(filePath)).toString() : undefined\n}\n\nexport const writeFile = async (\n  filePath: string,\n  data: string | Uint8Array\n) => {\n  await ensureDirExist(filePath)\n  await fs.promises.writeFile(filePath, data)\n  await fs.promises.chmod(filePath, 0o777)\n}\n\nexport const exec = async (cmd: string, options?: ExecOptions) => {\n  return await util.promisify(child_process.exec)(cmd, options)\n}\n\nexport const getLocalV4Ips = () => {\n  const interfaceDict = os.networkInterfaces()\n  const addresses: string[] = []\n  for (const key in interfaceDict) {\n    const interfaces = interfaceDict[key]\n    if (interfaces) {\n      for (const item of interfaces) {\n        if (item.family === 'IPv4') {\n          addresses.push(item.address)\n        }\n      }\n    }\n  }\n\n  return addresses\n}\n\nexport const getDefaultHosts = () => {\n  return ['localhost', ...getLocalV4Ips()]\n}\n\nexport const getHash = async (filePath: string) => {\n  const content = await readFile(filePath)\n\n  if (content) {\n    const hash = crypto.createHash('sha256')\n    hash.update(content)\n    return hash.digest('hex')\n  }\n\n  return undefined\n}\n\nconst isObj = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]'\n\nconst mergeObj = (target: any, source: any) => {\n  if (!(isObj(target) && isObj(source))) {\n    return target\n  }\n\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const targetValue = target[key]\n      const sourceValue = source[key]\n\n      if (isObj(targetValue) && isObj(sourceValue)) {\n        mergeObj(targetValue, sourceValue)\n      } else {\n        target[key] = sourceValue\n      }\n    }\n  }\n}\n\nexport const deepMerge = (target: any, ...source: any[]) => {\n  return source.reduce((a, b) => mergeObj(a, b), target)\n}\n\nexport const prettyLog = (obj?: Record<string, any>) => {\n  return JSON.stringify(obj, null, 2)\n}\n\nexport const escape = (path?: string) => {\n  return `\"${path}\"`\n}\n", "import fs from 'fs'\nimport process from 'process'\n\nimport pc from 'picocolors'\nimport { Logger } from 'vite'\n\nimport { debug } from '../lib/logger'\nimport {\n  ensureDirExist,\n  escape,\n  exec,\n  exists,\n  getHash,\n  prettyLog,\n  resolvePath\n} from '../lib/util'\n\nimport Config from './config'\nimport Downloader from './downloader'\nimport Record from './record'\nimport { BaseSource, GithubSource, CodingSource } from './source'\nimport VersionManger from './version'\n\nexport type SourceType = 'github' | 'coding' | BaseSource\n\nexport type MkcertOptions = {\n  /**\n   * Whether to force generate\n   */\n  force?: boolean\n\n  /**\n   * Automatically upgrade mkcert\n   *\n   * @default false\n   */\n  autoUpgrade?: boolean\n\n  /**\n   * Specify mkcert download source\n   *\n   * @default github\n   */\n  source?: SourceType\n\n  /**\n   * If your network is restricted, you can specify a local binary file instead of downloading\n   *\n   * @description it should be absolute path\n   * @default none\n   */\n  mkcertPath?: string\n}\n\nexport type MkcertProps = MkcertOptions & {\n  logger: Logger\n}\n\nconst KEY_FILE_PATH = resolvePath('certs/dev.key')\nconst CERT_FILE_PATH = resolvePath('certs/dev.pem')\n\nclass Mkcert {\n  private force?: boolean\n  private autoUpgrade?: boolean\n  private mkcertLocalPath?: string\n  private source: BaseSource\n  private logger: Logger\n\n  private mkcertSavedPath: string\n  private sourceType: SourceType\n\n  private config: Config\n\n  public static create(options: MkcertProps) {\n    return new Mkcert(options)\n  }\n\n  private constructor(options: MkcertProps) {\n    const { force, autoUpgrade, source, mkcertPath, logger } = options\n\n    this.force = force\n    this.logger = logger\n    this.autoUpgrade = autoUpgrade\n    this.mkcertLocalPath = mkcertPath\n    this.sourceType = source || 'github'\n\n    if (this.sourceType === 'github') {\n      this.source = GithubSource.create()\n    } else if (this.sourceType === 'coding') {\n      this.source = CodingSource.create()\n    } else {\n      this.source = this.sourceType\n    }\n\n    this.mkcertSavedPath = resolvePath(\n      process.platform === 'win32' ? 'mkcert.exe' : 'mkcert'\n    )\n\n    this.config = new Config()\n  }\n\n  private async getMkcertBinnary() {\n    return (await this.checkMkcert())\n      ? this.mkcertLocalPath || this.mkcertSavedPath\n      : undefined\n  }\n\n  /**\n   * Check if mkcert exists\n   */\n  private async checkMkcert() {\n    let exist: boolean\n    if (this.mkcertLocalPath) {\n      exist = await exists(this.mkcertLocalPath)\n      this.logger.error(\n        pc.red(\n          `${this.mkcertLocalPath} does not exist, please check the mkcertPath paramter`\n        )\n      )\n    } else {\n      exist = await exists(this.mkcertSavedPath)\n    }\n    return exist\n  }\n\n  private async getCertificate() {\n    const key = await fs.promises.readFile(KEY_FILE_PATH)\n    const cert = await fs.promises.readFile(CERT_FILE_PATH)\n\n    return {\n      key,\n      cert\n    }\n  }\n\n  private async createCertificate(hosts: string[]) {\n    const names = hosts.join(' ')\n\n    const mkcertBinnary = await this.getMkcertBinnary()\n\n    if (!mkcertBinnary) {\n      debug(\n        `Mkcert does not exist, unable to generate certificate for ${names}`\n      )\n    }\n\n    await ensureDirExist(KEY_FILE_PATH)\n    await ensureDirExist(CERT_FILE_PATH)\n\n    const cmd = `${escape(mkcertBinnary)} -install -key-file ${escape(\n      KEY_FILE_PATH\n    )} -cert-file ${escape(CERT_FILE_PATH)} ${names}`\n\n    await exec(cmd, {\n      env: {\n        ...process.env,\n        JAVA_HOME: undefined\n      }\n    })\n\n    this.logger.info(\n      `The certificate is saved in:\\n${KEY_FILE_PATH}\\n${CERT_FILE_PATH}`\n    )\n  }\n\n  private getLatestHash = async () => {\n    return {\n      key: await getHash(KEY_FILE_PATH),\n      cert: await getHash(CERT_FILE_PATH)\n    }\n  }\n\n  private async regenerate(record: Record, hosts: string[]) {\n    await this.createCertificate(hosts)\n\n    const hash = await this.getLatestHash()\n\n    record.update({ hosts, hash })\n  }\n\n  public async init() {\n    await this.config.init()\n\n    const exist = await this.checkMkcert()\n\n    if (!exist) {\n      await this.initMkcert()\n    } else if (this.autoUpgrade) {\n      await this.upgradeMkcert()\n    }\n  }\n\n  private async getSourceInfo() {\n    const sourceInfo = await this.source.getSourceInfo()\n\n    if (!sourceInfo) {\n      if (typeof this.sourceType === 'string') {\n        this.logger.error(\n          'Failed to request mkcert information, please check your network'\n        )\n        if (this.sourceType === 'github') {\n          this.logger.info(\n            'If you are a user in china, maybe you should set \"source\" paramter to \"coding\"'\n          )\n        }\n      } else {\n        this.logger.info(\n          'Please check your custom \"source\", it seems to return invalid result'\n        )\n      }\n      return undefined\n    }\n\n    return sourceInfo\n  }\n  private async initMkcert() {\n    const sourceInfo = await this.getSourceInfo()\n\n    debug('The mkcert does not exist, download it now')\n\n    if (!sourceInfo) {\n      this.logger.error(\n        'Can not obtain download information of mkcert, init skipped'\n      )\n      return\n    }\n\n    await this.downloadMkcert(sourceInfo.downloadUrl, this.mkcertSavedPath)\n  }\n\n  private async upgradeMkcert() {\n    const versionManger = new VersionManger({ config: this.config })\n    const sourceInfo = await this.getSourceInfo()\n\n    if (!sourceInfo) {\n      this.logger.error(\n        'Can not obtain download information of mkcert, update skipped'\n      )\n      return\n    }\n\n    const versionInfo = versionManger.compare(sourceInfo.version)\n\n    if (!versionInfo.shouldUpdate) {\n      debug('Mkcert is kept latest version, update skipped')\n      return\n    }\n\n    if (versionInfo.breakingChange) {\n      debug(\n        'The current version of mkcert is %s, and the latest version is %s, there may be some breaking changes, update skipped',\n        versionInfo.currentVersion,\n        versionInfo.nextVersion\n      )\n      return\n    }\n\n    debug(\n      'The current version of mkcert is %s, and the latest version is %s, mkcert will be updated',\n      versionInfo.currentVersion,\n      versionInfo.nextVersion\n    )\n\n    await this.downloadMkcert(sourceInfo.downloadUrl, this.mkcertSavedPath)\n    versionManger.update(versionInfo.nextVersion)\n  }\n\n  private async downloadMkcert(sourceUrl: string, distPath: string) {\n    const downloader = Downloader.create()\n    await downloader.download(sourceUrl, distPath)\n  }\n\n  public async renew(hosts: string[]) {\n    const record = new Record({ config: this.config })\n\n    if (this.force) {\n      debug(`Certificate is forced to regenerate`)\n\n      await this.regenerate(record, hosts)\n    }\n\n    if (!record.contains(hosts)) {\n      debug(\n        `The hosts changed from [${record.getHosts()}] to [${hosts}], start regenerate certificate`\n      )\n\n      await this.regenerate(record, hosts)\n      return\n    }\n\n    const hash = await this.getLatestHash()\n\n    if (record.tamper(hash)) {\n      debug(\n        `The hash changed from ${prettyLog(record.getHash())} to ${prettyLog(\n          hash\n        )}, start regenerate certificate`\n      )\n\n      await this.regenerate(record, hosts)\n      return\n    }\n\n    debug('Neither hosts nor hash has changed, skip regenerate certificate')\n  }\n\n  /**\n   * Get certificates\n   *\n   * @param hosts host collection\n   * @returns cretificates\n   */\n  public async install(hosts: string[]) {\n    if (hosts.length) {\n      await this.renew(hosts)\n    }\n\n    return await this.getCertificate()\n  }\n}\n\nexport default Mkcert\n", "import Debug from 'debug'\n\nimport { PLUGIN_NAME } from './constant'\n\nexport const debug = Debug(PLUGIN_NAME)\n", "import { debug } from '../lib/logger'\nimport {\n  resolvePath,\n  readFile,\n  writeFile,\n  prettyLog,\n  deepMerge\n} from '../lib/util'\n\nexport type RecordMate = {\n  /**\n   * The hosts that have generated certificate\n   */\n  hosts: string[]\n\n  /**\n   * file hash\n   */\n  hash?: RecordHash\n}\n\nexport type RecordHash = {\n  key?: string\n  cert?: string\n}\n\nconst CONFIG_FILE_NAME = 'config.json'\nconst CONFIG_FILE_PATH = resolvePath(CONFIG_FILE_NAME)\n\nclass Config {\n  /**\n   * The mkcert version\n   */\n  private version: string | undefined\n\n  private record: RecordMate | undefined\n\n  public async init() {\n    const str = await readFile(CONFIG_FILE_PATH)\n    const options = str ? JSON.parse(str) : undefined\n\n    if (options) {\n      this.version = options.version\n      this.record = options.record\n    }\n  }\n\n  private async serialize() {\n    await writeFile(CONFIG_FILE_PATH, prettyLog(this))\n  }\n\n  // deep merge\n  public async merge(obj: Record<string, any>) {\n    const currentStr = prettyLog(this)\n\n    deepMerge(this, obj)\n\n    const nextStr = prettyLog(this)\n\n    debug(\n      `Receive parameter ${prettyLog(\n        obj\n      )}, then update config from ${currentStr} to ${nextStr}`\n    )\n\n    await this.serialize()\n  }\n\n  public getRecord() {\n    return this.record\n  }\n\n  public getVersion() {\n    return this.version\n  }\n}\n\nexport default Config\n", "import axios from 'axios'\n\nimport { debug } from './logger'\n\nconst request = axios.create()\n\nrequest.interceptors.response.use(\n  res => {\n    return res\n  },\n  error => {\n    debug('Request error: %o', error)\n    return Promise.reject(error)\n  }\n)\n\nexport default request\n", "import { debug } from '../lib/logger'\nimport request from '../lib/request'\nimport { writeFile } from '../lib/util'\n\nclass Downloader {\n  public static create() {\n    return new Downloader()\n  }\n\n  private constructor() {}\n\n  public async download(downloadUrl: string, savedPath: string) {\n    debug('Downloading the mkcert executable from %s', downloadUrl)\n\n    const { data } = await request.get(downloadUrl, {\n      responseType: 'arraybuffer'\n    })\n\n    await writeFile(savedPath, data)\n\n    debug('The mkcert has been saved to %s', savedPath)\n  }\n}\n\nexport default Downloader\n", "import Config, { RecordHash, RecordMate } from './config'\n\nexport type RecordProps = {\n  config: Config\n}\nclass Record {\n  private config: Config\n\n  constructor(options: RecordProps) {\n    this.config = options.config\n  }\n\n  public getHosts() {\n    return this.config.getRecord()?.hosts\n  }\n\n  public getHash() {\n    return this.config.getRecord()?.hash\n  }\n\n  public contains(hosts: string[]) {\n    const oldHosts = this.getHosts()\n\n    if (!oldHosts) {\n      return false\n    }\n\n    // require hosts is subset of oldHosts\n    for (const host of hosts) {\n      if (!oldHosts.includes(host)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  // whether the files has been tampered with\n  public tamper(hash: RecordHash) {\n    const oldHash = this.getHash()\n\n    if (!oldHash) {\n      return false\n    }\n\n    if (oldHash.key === hash.key && oldHash.cert === hash.cert) {\n      return false\n    }\n\n    return true\n  }\n\n  public async update(record: RecordMate) {\n    await this.config.merge({ record })\n  }\n}\n\nexport default Record\n", "import { Octokit } from '@octokit/rest'\n\nimport request from '../lib/request'\n\nexport type SourceInfo = {\n  version: string\n  downloadUrl: string\n}\n\nexport abstract class BaseSource {\n  abstract getSourceInfo(): Promise<SourceInfo | undefined>\n\n  protected getPlatformIdentifier() {\n    switch (process.platform) {\n      case 'win32':\n        return 'windows-amd64.exe'\n      case 'linux':\n        return process.arch === 'arm64'\n          ? 'linux-arm64'\n          : process.arch === 'arm'\n          ? 'linux-arm'\n          : 'linux-amd64'\n      case 'darwin':\n        return 'darwin-amd64'\n      default:\n        throw new Error('Unsupported platform')\n    }\n  }\n}\n\n/**\n * Download mkcert from github.com\n */\nexport class GithubSource extends BaseSource {\n  public static create() {\n    return new GithubSource()\n  }\n\n  private constructor() {\n    super()\n  }\n\n  public async getSourceInfo(): Promise<SourceInfo | undefined> {\n    const octokit = new Octokit()\n    const { data } = await octokit.repos.getLatestRelease({\n      owner: 'FiloSottile',\n      repo: 'mkcert'\n    })\n    const platformIdentifier = this.getPlatformIdentifier()\n\n    const version = data.tag_name\n    const downloadUrl = data.assets.find(item =>\n      item.name.includes(platformIdentifier)\n    )?.browser_download_url\n\n    if (!(version && downloadUrl)) {\n      return undefined\n    }\n\n    return {\n      downloadUrl,\n      version\n    }\n  }\n}\n\n/**\n * Download mkcert from coding.net\n *\n * @see {https://help.coding.net/openapi}\n */\nexport class CodingSource extends BaseSource {\n  public static CODING_API = 'https://e.coding.net/open-api'\n  public static CODING_AUTHORIZATION =\n    'token 000f7831ec425079439b0f55f55c729c9280d66e'\n  public static CODING_PROJECT_ID = 8524617\n  public static REPOSITORY = 'mkcert'\n\n  public static create() {\n    return new CodingSource()\n  }\n\n  private constructor() {\n    super()\n  }\n\n  private async request(data: any) {\n    return request({\n      data,\n      method: 'POST',\n      url: CodingSource.CODING_API,\n      headers: {\n        Authorization: CodingSource.CODING_AUTHORIZATION\n      }\n    })\n  }\n\n  /**\n   * Get filename of Coding.net artifacts\n   *\n   * @see https://liuweigl.coding.net/p/github/artifacts/885241/generic/packages\n   *\n   * @returns name\n   */\n  private getPackageName() {\n    return `mkcert-${this.getPlatformIdentifier()}`\n  }\n\n  async getSourceInfo(): Promise<SourceInfo | undefined> {\n    /**\n     * @see https://help.coding.net/openapi#e2106ec64e75af66f188463b1bb7e165\n     */\n    const { data: VersionData } = await this.request({\n      Action: 'DescribeArtifactVersionList',\n      ProjectId: CodingSource.CODING_PROJECT_ID,\n      Repository: CodingSource.REPOSITORY,\n      Package: this.getPackageName(),\n      PageSize: 1\n    })\n\n    const version = VersionData.Response.Data.InstanceSet[0]?.Version\n\n    if (!version) {\n      return undefined\n    }\n\n    /**\n     * @see https://help.coding.net/openapi#63ad6bc7469373cef575e92bb92be71e\n     */\n    const { data: FileData } = await this.request({\n      Action: 'DescribeArtifactFileDownloadUrl',\n      ProjectId: CodingSource.CODING_PROJECT_ID,\n      Repository: CodingSource.REPOSITORY,\n      Package: this.getPackageName(),\n      PackageVersion: version\n    })\n\n    const downloadUrl = FileData.Response.Url\n\n    if (!downloadUrl) {\n      return undefined\n    }\n\n    return {\n      downloadUrl,\n      version\n    }\n  }\n}\n", "import { debug } from '../lib/logger'\n\nimport Config from './config'\n\nexport type VersionMangerProps = {\n  config: Config\n}\n\nconst parseVersion = (version: string) => {\n  const str = version.trim().replace(/v/i, '')\n\n  return str.split('.')\n}\n\nclass VersionManger {\n  private config: Config\n\n  public constructor(props: VersionMangerProps) {\n    this.config = props.config\n  }\n\n  public async update(version: string) {\n    try {\n      await this.config.merge({ version })\n    } catch (err) {\n      debug('Failed to record mkcert version info: %o', err)\n    }\n  }\n\n  public compare(version: string) {\n    const currentVersion = this.config.getVersion()\n\n    if (!currentVersion) {\n      return {\n        currentVersion,\n        nextVersion: version,\n        breakingChange: false,\n        shouldUpdate: true\n      }\n    }\n\n    let breakingChange = false\n    let shouldUpdate = false\n\n    const newVersion = parseVersion(version)\n    const oldVersion = parseVersion(currentVersion)\n\n    for (let i = 0; i < newVersion.length; i++) {\n      if (newVersion[i] > oldVersion[i]) {\n        shouldUpdate = true\n        breakingChange = i === 0\n        break\n      }\n    }\n    return {\n      breakingChange,\n      shouldUpdate,\n      currentVersion,\n      nextVersion: version\n    }\n  }\n}\n\nexport default VersionManger\n"],
  "mappings": "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",
  "names": []
}
